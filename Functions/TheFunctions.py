"""Многоразовость Организационная семантика
Инструкции 
инкапсулированы, что дает 
более читабельный 
код, меньше ошибок и 
снижение затрат на обслуживание 
стоимость. 
Функция будет иметь 
имя. Это означает, что мы 
можем вызывать ее в любое время (она 
вызываемая) и повторно использовать 
код, вместо того чтобы 
повторять его. 
Инструкции, которые работают 
вместе, четко 
четко обозначены в коде 
коде. Улучшает 
удобочитаемость.


● def сообщает Python, что это функция
● hello_world - это имя, которое мы ей даем
● () указывает на отсутствие аргументов
● : указывает на конец заголовка
Набор инструкций для выполнения задачи, в данном случае 
В данном случае - печать "Hello World!". Первая строка может 
содержать строку, которая служит в качестве 
документацией (docstring).
Тело функции должно быть 

Использование функции
Для вызова (использования) функции достаточно 
написать ее имя с открывающей и 
закрывающей круглой скобкой.
"""
def hello_world():
    
    print("Hello World!")
hello_world()






"""


входной аргумент
Выходной аргумент
Наша функция выводит строку, содержащую 
имя человека, посланного в 
функция. Чтобы указать интерпретатору, что 
должна вернуть функция, мы используем 
зарезервированное слово return.
Наша функция требует входной аргумент 
содержащий строку с именем 
человека, которого нужно поприветствовать. Внутри функции мы будем 
иметь переменную name, содержащую 
содержимым текста, передаваемого в функцию.
Использование функции
Для вызова (использования) функции с аргументами 
достаточно включить их между 
круглыми скобками. Выходные данные функции 
функции может быть сохранен в переменной 
имя, в данном случае приветствие.
"""
def greet(name):
    return f"Hello {name}!"
 
greeting = greet("World")
print(greeting)



"""

Выполняет любые инструкции перед 
определения функции.
1. Считывает функцию и сохраняет ее, но не 
не выполняет ее инструкции.
1. Выполняет любые инструкции после определения функции 
определения.
1. Когда мы вызываем функцию, перемещает указатель 
на функцию и выполняет ее содержимое.
1. По окончании работы возвращается в то место, где был до этого 
и продолжает выполнять 
оставшиеся инструкции.Выполнение"""

my_variable = "A string"

def hello_world():
    print("I’m inside")
my_other_variable = 1
hello_world()
print("I’m outside")

"""
входные аргументы
Позиционные аргументы
Данная функция определяет два параметра.

Браун Джеймс Эти параметры называются позиционными 
аргументами, потому что имя переменной 
имя переменной, которой они присваиваются, зависит 
от их положения в вызове.
При вызове мы определяем два значения для 
этих аргументов, причем в одном и том же порядке.
Если мы изменим положение аргументов 
в вызове, то вывод изменится
"""
def full_name(first, last):
 return f"{first} {last}!"

friend = full_name("James", "Brown")
print(friend)
#James Brown
 
"""


Аргументы ключевых слов
Это та же самая функция.
Но теперь при вызове функции аргументы именуются в 
скобках при вызове функции.
Если мы изменим положение аргументов 
в вызове, то результат останется прежним
Такие аргументы называются ключевыми 
аргументы, поскольку имя переменной 
имя переменной, которой они присваиваются, зависит 
от ключевого слова в вызове.
"""
def full_name(first, last):
     return f"{first} {last}!"
 
print(full_name(first="James",
                    last="Brown" ))
#James Brown
'Keyword arguments'
print(full_name(
     last="Brown",
     first="James"
 ))
#James Brown


"""

Мы можем определить значение по умолчанию в 
заголовке с помощью знака равенства =.
Если мы не укажем ни один из аргументов, то 
будет использоваться значение по умолчанию.
Мы по-прежнему можем использовать позиционные аргументы, 
но мы не можем получить "Джона Брауна" таким образом. 
способом."""

def full_name(first="John", last="Doe"):
    return f"{first} {last}"
 
print(full_name(first="James"))
#James Doe
print(full_name(last="Brown"))
#John Brown
print(full_name("James", "Brown"))
#James Brown
print(full_name("James"))
#James Doe


"""


Комбинирование с параметрами не по умолчанию
Если у нас есть параметры со значениями по умолчанию и 
без значений по умолчанию, то сначала нужно 
определить аргументы, не имеющие значения по умолчанию, и 
а стандартные оставить в конце.
Аргументы по умолчанию должны быть 
определяться в конце в 
заголовке функции.
Если определить аргументы по умолчанию 
сначала, то интерпретатор выдаст ошибку 
ошибку"""

def full_name(first, last="Doe"):
    return f"{first} {last}"

"""def full_name(first="John", last):
    return f"{first} {last}"
File "<stdin>", line 1
SyntaxError: non-default argument follows 
default argument
"""




"""Список
● Список - это встроенная структура данных, представляющая собой упорядоченную коллекцию элементов 
элементов.
Списки создаются с использованием квадратных скобок, а элементы разделяются запятыми.
Пример:
my_list = [1, 2, 3, "four", 5.0]
Создается список из 5 элементов, включая целые числа, строку и число с плавающей точкой 
число. 
Доступ к элементам списка
Доступ к отдельным элементам списка осуществляется по их индексу, который начинается с 0. 
Например:
"""
my_list = [1, 2, 3, "four", 5.0]
print(my_list[0])  
#Output: 1
print(my_list[3])
#Output: "four"






"""

Упаковка и распаковка аргументов
Позиционные аргументы
Мы можем автоматически упаковать все 
входящие позиционные аргументы в список 
список с помощью оператора *.
Это преобразует серию элементов в 
список с этими элементами.
С помощью того же оператора * мы можем 
сделать обратное и распаковать все 
элементы в данные списка, чтобы передать их 
в функцию"""
def full_name(*args):
    return f"{args[0]} {args[1]}!"
 
friend = full_name("James", "rown")
print(friend)
#James Brown
def full_name(*args):
    return f"{args[0]} {args[1]}"

data = ["James", "Brown"]
friend = full_name(*data)
print(friend)
# James Brown






"""
Словарь
● Словарь - это встроенная структура данных, представляющая собой набор пар ключ-значение.
пар значений. 
Каждый ключ в словаре сопоставляется с соответствующим значением, и вы можете использовать ключ для поиска значения. 
ключ для поиска значения.
Словари создаются с помощью фигурных скобок, пары ключ-значение разделяются двоеточиями. 
двоеточиями, а каждая пара ключ-значение - запятыми.
Пример:
"""
my_dict = {"name": "Alice", "age": 30, "city": "New York"}



"""

Доступ к значениям словаря
my_dict = {"имя": "Алиса", "возраст": 30, "city": "Нью-Йорк"}
В результате создается словарь с тремя парами ключ-значение,
 где "имя", "возраст" и "город" - ключи, а "Алиса", "30" и "Нью-Йорк" - ключи. 
"город" являются ключами, а "Алиса", 30 и "Нью-Йорк" -
 соответствующими значениями. 
значения.
● Мы можем получить доступ к значению, связанному с 
ключом, используя квадратные скобки
"""
print(my_dict["name"])
#Output: "Alice"
print(my_dict["age"])
#Output: 30



"""


Аргументы упаковки и распаковки
Аргументы для ключевых слов
Мы можем автоматически упаковывать все 
входящие аргументы с ключевыми словами в словарь 
с помощью оператора **.
Это преобразует ряд именованных 
элементов в словарь с этими 
элементами.
С помощью того же оператора ** мы также можем 
сделать обратное и распаковать все 
элементы в словарные данные, чтобы передать их 
их в функцию в качестве ключевых слов 
аргументы.
"""
def full_name(**kwargs):
    first = kwargs["first"]
    last = kwargs["last"]
    return f"{first} {last}!"

data = {
    "first": "James", 
    "last": "Brown"
 }
friend = full_name(**data)
print(friend)
# James Brown


"""

Аргументы упаковки и распаковки
Позиционные и ключевые слова
Мы можем упаковать оба аргумента одновременно в 
заголовок функции, объединив 
их.
Упакованные переменные часто называются 
args и kwargs, но они могут принимать любое 
имя по своему усмотрению"""
def full_name(*args, **kwargs):
    first = kwargs["first"]
    last = kwargs["last"]
    return f"{args[0], {first} ,{last}}"
 
data = {
  "first": "James", 
  "last": "Brown"
 }
friend = full_name("Mr", **data)
print(friend)
# James Brown












































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































