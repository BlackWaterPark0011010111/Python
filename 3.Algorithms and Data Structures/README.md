        бинарный поиск хорош при отсортированном списке
  

Массивы и связанные списки

Иногда в памяти требуется сохранить список элементов. Предположим, вы пишете приложение для управления текущими делами. Описания задач должны храниться в виде списка в памяти.

Что использовать — массив или связанный список? Для начала попробуем сохранить задачи в массиве, потому что этот способ более понятен. При использовании массива все задачи хранятся в памяти непрерывно (то есть рядом друг с другом).


Dы захотели добавить четвертую задачу. Но следующий ящик уже занят — там лежат чужие вещи!


мы пошли в кино с друзьями и нашли места для своей компании, но тут приходит еще один друг, и ему сесть уже некуда. Приходится искать новое место, где смогут разместиться все. В этом случае вам придется запросить у компьютера другой блок памяти, в котором поместятся все четыре задачи, а потом переместить все свои задачи туда.

Если вдруг придет еще один друг, места опять не хватит, и вам всем придется перемещаться снова! Сплошная суета. Кроме того, добавление новых элементов в массив станет серьезной проблемой. Если свободного места нет и вам каждый раз приходится перемещаться в новую область в памяти, операция добавления нового элемента будет выполняться очень медленно. Простейшее решение — «бронирование мест»: даже если список состоит всего из 3 задач, вы запрашиваете у компьютера место на 10 позиций… просто на всякий случай. Тогда в список можно будет добавить до 10 задач, и ничего перемещать не придется. Это неплохое обходное решение, но у него есть пара недостатков:

• Лишнее место может не понадобиться, и тогда память будет расходоваться неэффективно. Вы ее не используете, однако никто другой ее использовать тоже не может.

• Если в список будет добавлено более 10 задач, перемещаться все равно придется.

В общем, прием неплохой, но его нельзя назвать идеальным. Связанные списки решают проблему добавления новых элементов.


Связанные списки

элементы могут размещаться где угодно в памяти. хаотично

В каждом элементе хранится адрес следующего элемента списка. и набор произвольных адресов памяти объединяется в цепочку.

Связанные адреса памяти

как в игре «Найди клад». приходим по первому адресу, там написано: «Следующий элемент находится по адресу 123». Вы идете по адресу 123, там написано: «Следующий элемент находится по адресу 847» и т.д. Добавить новый элемент в связанный список проще простого: просто разместите его по любому адресу памяти и сохраните этот адрес в предыдущем элементе.

Со связанными списками ничего перемещать в памяти не нужно. Также сама собой решается другая проблема: допустим, вы пришли в кино с пятью друзьями. Вы пытаетесь найти место на шестерых, но кинотеатр уже забит, и найти шесть соседних мест невозможно. Нечто похожее происходит и с массивами. Допустим, вы пытаетесь найти для массива блок на 10 000 элементов. В памяти можно найти место для 10 000 элементов, но только не смежное. Для массива не хватает места! При хранении данных в связанном списке вы фактически говорите: «Ладно, тогда садимся на свободные места и смотрим кино». Если необходимое место есть в памяти, вы сможете сохранить данные в связанном списке.

Если связанные списки так хорошо справляются со вставкой, то чем тогда хороши массивы?



Массивы

На сайтах со всевозможными хит-парадами и «первыми десятками» применяется жульническая тактика для увеличения количества просмотров. Вместо того чтобы вывести весь список на одной странице, они размещают по одному элементу на странице и заставляют вас нажимать кнопку Next для перехода к следующему элементу. Например, «Десятка лучших злодеев в сериалах» не выводится на одной странице. Вместо этого вы начинаете с № 10 (Ньюман из «Сайнфелда») и нажимаете Next на каждой странице, пока не доберетесь до № 1 (Густаво Фринг из «Во все тяжкие»). В результате сайту удается показать вам рекламу на целых 10 страницах, но нажимать Next 9 раз для перехода к первому месту скучно. Было бы гораздо лучше, если бы весь список помещался на одной странице, а вы бы могли просто щелкнуть на имени человека для получения дополнительной информации.



Похожая проблема существует и у связанных списков. 
потому что чтобы добраться до последнего элемента в связном списке,нужно идти по каждому из существующих,пока не дойду до нужного,потому что я например не знаю где он находится,по какому адресу он хранится и придется сначала обратиться к элементу № 1 и узнать адрес элемента № 2, потом обратиться к элементу № 2 и узнать адрес элемента № 3… и так далее, пока не доберетесь до последнего элемента. Связанные списки отлично подходят в тех ситуациях, когда данные должны читаться последовательно: сначала вы читаете один элемент, по адресу переходите к следующему элементу и т.д. Но если вы намерены прыгать по списку туда-сюда, держитесь подальше от связанных списков.

при работе с массивом я знаю уже адреса элементов по ихнему индексу по умолчанию. и если массив на 5 элементов то начинается с 0 и до 4х. все известно.


при создания списка растрат за месяц,каждый день добавляю новые записи и в конце месяца анализирую все. массив или список- какая структура?


Вставка в середину списка
есть список задач и он должен напоминать календарь. раньше все добавлялось в конец а теперь должны добавляться по приоритету выполнения. что лучше  для вставки элементов в середину:массивы или списки?
решается изменением указателя в предыдущем элементе а при работе с массивом нудно сдвигать все остальные элементы.списки лучше подходят для вставки элементов в середину. и в отличии от вставки удаление возможно всегда. и если удалить элемент,в нем достаточно изменить указатель в предыдущем  элементе.в массиве при удалении элемента все последующие элементы нужно сдвигать вверх.
массивы поддерживают произвольный доступ.
есть произвольный и последовательный.
про последовательный доступ-элементы читаются по одному начиная с первого. связные списки поддерживают только последовательный доступ. если нужно прочитать 10й элемент связного списка,то нужно прочитать первые 9 и перейти по ссылке к 10-му. 
массивы обладают более быстрой скоростью чтения потому что обладают произвольным доступом. связанные списки хорошо подходят для вставки/удаления, а массивы — для произвольного доступа к элементам.
  
Вставка в середину
если есть список и он масштабный,как календарь. раньше данные добавлялись в конец списка,а теперь они должны добавляться в порядке их выполнения.
 
  

Гибридная структура
массив связных списков

что чаще списки или массивы?
Списки используются в 99%+ случаев. Это стандартная, гибкая структура для любых данных.

Массивы (array.array) — узкая специализация. Нужны, только если жёстко экономишь память и работаешь напрямую с бинарными данными/C-кодом (используешь протокол буфера).


Когда вы пишете рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента.


связанные списки хорошо подходят для вставки/удаления, а массивы — для произвольного доступа к элементам.

