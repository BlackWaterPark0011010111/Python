        бинарный поиск хорош при отсортированном списке
  

Массивы и связанные списки

Иногда в памяти требуется сохранить список элементов. Предположим, вы пишете приложение для управления текущими делами. Описания задач должны храниться в виде списка в памяти.

Что использовать — массив или связанный список? Для начала попробуем сохранить задачи в массиве, потому что этот способ более понятен. При использовании массива все задачи хранятся в памяти непрерывно (то есть рядом друг с другом).


Dы захотели добавить четвертую задачу. Но следующий ящик уже занят — там лежат чужие вещи!


мы пошли в кино с друзьями и нашли места для своей компании, но тут приходит еще один друг, и ему сесть уже некуда. Приходится искать новое место, где смогут разместиться все. В этом случае вам придется запросить у компьютера другой блок памяти, в котором поместятся все четыре задачи, а потом переместить все свои задачи туда.

Если вдруг придет еще один друг, места опять не хватит, и вам всем придется перемещаться снова! Сплошная суета. Кроме того, добавление новых элементов в массив станет серьезной проблемой. Если свободного места нет и вам каждый раз приходится перемещаться в новую область в памяти, операция добавления нового элемента будет выполняться очень медленно. Простейшее решение — «бронирование мест»: даже если список состоит всего из 3 задач, вы запрашиваете у компьютера место на 10 позиций… просто на всякий случай. Тогда в список можно будет добавить до 10 задач, и ничего перемещать не придется. Это неплохое обходное решение, но у него есть пара недостатков:

• Лишнее место может не понадобиться, и тогда память будет расходоваться неэффективно. Вы ее не используете, однако никто другой ее использовать тоже не может.

• Если в список будет добавлено более 10 задач, перемещаться все равно придется.

В общем, прием неплохой, но его нельзя назвать идеальным. Связанные списки решают проблему добавления новых элементов.


Связанные списки

элементы могут размещаться где угодно в памяти. хаотично

В каждом элементе хранится адрес следующего элемента списка. и набор произвольных адресов памяти объединяется в цепочку.

Связанные адреса памяти

как в игре «Найди клад». приходим по первому адресу, там написано: «Следующий элемент находится по адресу 123». Вы идете по адресу 123, там написано: «Следующий элемент находится по адресу 847» и т.д. Добавить новый элемент в связанный список проще простого: просто разместите его по любому адресу памяти и сохраните этот адрес в предыдущем элементе.

Со связанными списками ничего перемещать в памяти не нужно. Также сама собой решается другая проблема: допустим, вы пришли в кино с пятью друзьями. Вы пытаетесь найти место на шестерых, но кинотеатр уже забит, и найти шесть соседних мест невозможно. Нечто похожее происходит и с массивами. Допустим, вы пытаетесь найти для массива блок на 10 000 элементов. В памяти можно найти место для 10 000 элементов, но только не смежное. Для массива не хватает места! При хранении данных в связанном списке вы фактически говорите: «Ладно, тогда садимся на свободные места и смотрим кино». Если необходимое место есть в памяти, вы сможете сохранить данные в связанном списке.

Если связанные списки так хорошо справляются со вставкой, то чем тогда хороши массивы?



Массивы

На сайтах со всевозможными хит-парадами и «первыми десятками» применяется жульническая тактика для увеличения количества просмотров. Вместо того чтобы вывести весь список на одной странице, они размещают по одному элементу на странице и заставляют вас нажимать кнопку Next для перехода к следующему элементу. Например, «Десятка лучших злодеев в сериалах» не выводится на одной странице. Вместо этого вы начинаете с № 10 (Ньюман из «Сайнфелда») и нажимаете Next на каждой странице, пока не доберетесь до № 1 (Густаво Фринг из «Во все тяжкие»). В результате сайту удается показать вам рекламу на целых 10 страницах, но нажимать Next 9 раз для перехода к первому месту скучно. Было бы гораздо лучше, если бы весь список помещался на одной странице, а вы бы могли просто щелкнуть на имени человека для получения дополнительной информации.



Похожая проблема существует и у связанных списков. 
потому что чтобы добраться до последнего элемента в связном списке,нужно идти по каждому из существующих,пока не дойду до нужного,потому что я например не знаю где он находится,по какому адресу он хранится и придется сначала обратиться к элементу № 1 и узнать адрес элемента № 2, потом обратиться к элементу № 2 и узнать адрес элемента № 3… и так далее, пока не доберетесь до последнего элемента. Связанные списки отлично подходят в тех ситуациях, когда данные должны читаться последовательно: сначала вы читаете один элемент, по адресу переходите к следующему элементу и т.д. Но если вы намерены прыгать по списку туда-сюда, держитесь подальше от связанных списков.

при работе с массивом я знаю уже адреса элементов по ихнему индексу по умолчанию. и если массив на 5 элементов то начинается с 0 и до 4х. все известно.


при создания списка растрат за месяц,каждый день добавляю новые записи и в конце месяца анализирую все. массив или список- какая структура?


Вставка в середину списка
есть список задач и он должен напоминать календарь. раньше все добавлялось в конец а теперь должны добавляться по приоритету выполнения. что лучше  для вставки элементов в середину:массивы или списки?
решается изменением указателя в предыдущем элементе а при работе с массивом нудно сдвигать все остальные элементы.списки лучше подходят для вставки элементов в середину. и в отличии от вставки удаление возможно всегда. и если удалить элемент,в нем достаточно изменить указатель в предыдущем  элементе.в массиве при удалении элемента все последующие элементы нужно сдвигать вверх.
массивы поддерживают произвольный доступ.
есть произвольный и последовательный.
про последовательный доступ-элементы читаются по одному начиная с первого. связные списки поддерживают только последовательный доступ. если нужно прочитать 10й элемент связного списка,то нужно прочитать первые 9 и перейти по ссылке к 10-му. 
массивы обладают более быстрой скоростью чтения потому что обладают произвольным доступом. связанные списки хорошо подходят для вставки/удаления, а массивы — для произвольного доступа к элементам.
  
Вставка в середину

Списки лучше подходят для вставки элементов в середину.

Если есть список и он масштабный,как календарь. раньше данные добавлялись в конец списка,а теперь они должны добавляться в порядке их выполнения. и что лучше для вставки в середину,массивы или списки? Со списком задача решается изменением указателя в предыдущем элементе,а при работе с массивом придется сдвигать вниз все остальные элементы. ну а если свободного места не осталось,то все данные придется копировать в новую область памяти. Списки лучше подходят для вставки элементов в середину. И если нужно будет удалить элемент?
Опять список тут подходит лучше для операции,потому что в нем достаточно изменить указатель в предыдущем элементе. В массиве при удалении,все последующие элементы нежно сдвинуть вверх,в отличии от вставки удаление возможно всегда.если в памяти неосталось свободного места- то попытка вставки может быть неудачной. С удалением проблем нет.


__________________________
        | Массивы |Списки |  
Чтение  |  О(1)   | О(n)  | 
Вставка |  О(n)   | О(1)  | 
Удаление|  О(n)   | О(1)  |
---------------------------

Вставка и удаление выполняются за время О(1),только в том случае,если мы можем мгновенно  получить доступ к удаляемому элементу,обычно созраняются ссылки на первый и последний элементы связанного списка,поэтому время удаления этих элементов составит О(1)

массив
arr = [10, 20, 30, 40, 50]
value = arr[2]  #получаем доступ к 3-му элементу
print(value)  

arr.insert(2, 25)  #вставка 25 на место2. O(n)-нужно сдвинуть элементы
print(arr)         #будет[10, 20, 25, 30, 40, 50]
Все элементы после позиции 2 сдвинулись вправо

УДАЛЕНИЕ
del arr[3]  # Удаляем элемент на позиции 3.  O(n)-нужно сдвинуть элементы
print(arr)  # [10, 20, 25, 40, 50]
Все элементы после позиции 3 сдвинулись влево

---------------------------------------------
СВЯЗНЫЙ СПИСОК
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

Создаем список: 10 -- 20 -- 30
node1 = Node(10)
node2 = Node(20)
node3 = Node(30)
node1.next = node2
node2.next = node3

О(1) вставка-если уже знаем узел

new_node = Node(25) -- Вставляем 25 между node2 и node3
new_node.next = node3  # 25 → 30
node2.next = new_node  # 20 → 25
Будет: 10 -20 - 25 - 30

О(1) удаляем если уже знаем узел и предыдущий
Удаляем node3
node2.next = node3.next  #20 ---None (пропускаем 30)
10 - 20 - 25

Что чаще используется :массивы или списки?
массивы популярны из-за того,что поддерживают произвольный доступ.
Есть произвольный и последовательный ......
При последовательном,элементы читаются по одному,начиная с первого.Связные списки поддерживают только последовательный доступ и если нужно будет прочитать 10-й эл., то нужно будет читать первые 9 и переходить по ссылке к 10-му.Массивы быстрые по чтению из-за произвольного доступа.

Сортировки выбором
Есть список артистов составленный в хаотичном порядке.Нужно отсортировать любимые воспроизведения по убыванию,чтобы самые любимые стояли в начале. Время О(n) означает,что мы по одному разу обращаемся к каждому элементу. при простом поиске по списку,каждый исполнитель будет проверен один раз. нужно выполнить операцию n-раз за О(n)- время. и при каждом выполнении операции, количество элементов сокращается.Сначала проверяются N-элементов,потом n-1,n-2 и в среднем проверяется список из 1/2 * n элементов. и время выполнения составит О(n * 1/2 * n). Но константы как 1/2 игнорируются, и мы просто исполбзуем О(n * n) или О(n2).

алгоритм сортировки выбором легко объясняется, но медленно работает. Быстрая сортировки- эффективный алгоритм сортировки,который выполняется за время О(n log n). 


В массиве все элементы хранятся в памяти рядом друг с другом.
В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе хранится адрес следующего элемента.

Массивы ---для быстрого чтения.
списки --- для быстрой вставки и удаления и выполнения.
все элементы массива должны быть однотипны(только целые числа,только вещественные числа и тд)

Рекурсия

есть чулан,в котором лежит чемодан и большая коробка. и нужно в коробке найти ключ от чемодана. в большой коробке ,есть куча вложенных коробок.
мы складываем все коробки в кучу.

Взять коробку и открыть.
Если внутри лежит коробка, добавить ее в кучу для последующего поиска.
Если внутри лежит ключ, поиск закончен!
Повторить.
```
def look_for_key(main_box):
    pile = main_box.make_a_pile_to_look_through()
    
    while pile is not empty:
        box = pile.grab_a_box()
        
        for item in box:
            if item.is_a_box():
                pile.append(item)
            elif item.is_a_key():
                print("found the key!")
                
```
2й вариант
1.проверить каждый предмет в коробке
2.если находим еще коробку,возвращаемся к пункту 1.
2.если нашли ключ,поиск окончен.
```
def look_for_key(box):
    for item in box:
        if item.is_a_box():
            look_for_key(item)  #рекурсия
        elif item.is_a_key():
            print("found the key!")

```

при написании рекурсивной функции- нужно указать в какой момент следует прервать рекурсию.
рекурсивная функция состоит из двух частей:базового и рекурсивного:
```
def countdown(i):
    print i
    if i <= 0:       Базовый случай
         return
    else:            Рекурсивный случай
         countdown(i-1)
```


Стек
Стек вызовов
стек важен для рекурсии. внутренняя работа пк - основана на стеке,стеке вызовов.
def greet(name):
    print('Hello ' + name + '!')
    greet2(name)
    print("greeting ready to say bye")
    bye()  


def bye():
    print("ok, bye")

def greet2(name):
    print("H r u?")
greet("Alice")
Здесь мы выделяем блок памяти для вызова функции и при вызове функции компьютер сохраняет в памяти все переменные и после второй вызов greet2. и снова сохранение в памяти в новом блоке для вызова. и это все объединяется в стек. 1 функция -это блок,2-я функция это блок и они обьеденены в стек. и второй блок,создается над первым. когда мы запускаем блок с 'h r u?',то есть когда greet2 вызывается из greet, она становится текущей выполняемой функцией,а Greet временно откладывается,мы выводим сообщение 'h r u?' -- выполняем код внутри greet2,и greet2 заканчивает свою работу. и после функция greet2 удаляется из памяти как выполненная задача и фокусировка переключается обратно на первую greet() функцию. 
и подобный стек,в котором созранялись все переменные разных функций- это стек.

Стек с рекурсией

1def fact(x):
2   if x==1:
        return 1
3    else:
4        return x * fact(x-1)

1 print(fact(3)) 

тут,как только мы даем значение3 мы создаем блок где х присваивается 3 в 1-ом пункте,потом проходим по второму,ничего не меняется,по третьему,все так же блок остается только с 3-йкой в блоке, и как только доходим до 4-й строки,там уже происходит действие,мы отнимаем 1-цу,и теперь наш блок пополняется 2-кой,теперь в памяти не только х=3,но и х=2. и опять мы проходим по циклу,пока не дойдем до 4-го пункта где еще отнимает единицу,и в блоке уже х=3,х=2 и х=1.  у нас уже 3 вызова функции,которые не завершаются и самый последний результат,что мы получим,будет первым блоком,который  который будет извлечен из памяти и первым что вернет результат в памяти 1-цу,потом 2-ку,потом 6-ку.и в итоге мы видим 6. при каждом вызове,создается своя отдельная копия х. и при обращении  к х,если он будет принадлежать другой функции-так не получится


Гибридная структура
массив связных списков

что чаще списки или массивы?
Списки используются в 99%+ случаев. Это стандартная, гибкая структура для любых данных.

Массивы (array.array) — узкая специализация. Нужны, только если жёстко экономишь память и работаешь напрямую с бинарными данными/C-кодом (используешь протокол буфера).


Когда вы пишете рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента.


связанные списки хорошо подходят для вставки/удаления, а массивы — для произвольного доступа к элементам.

 Ли Колдуэлла (Stack Overlow): Циклы могут ускорить работу программы. Рекурсия может ускорить работу программиста.