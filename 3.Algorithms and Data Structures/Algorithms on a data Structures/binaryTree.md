

Бинарное дерево Динамические структуры данных

это упорядоченная структура данных  и поскольку они разветвляются как корни,то начинаются с верха самого корня(NULL,вершина) (сначала из одного ->2, потом из этих 2 -->4) и у каждого есть дочерние элементы.

          5
        /   \
      3       8
     / \     / \  
    1   4   6   9
    |   |   |   |
null null null null
что есть- у левого дочернего элемента значение всегда меньше родительского а правый обязательно больше родительского.
тут есть высота,то есть количество уровней и для просчета количества элементов в нашем дереве есть формула:N ≈ 2`H(2 в степени H ),но она работает только в том случае,если каждый уровень в дереве он одинаков с количеством разветвлений,с количеством узлов уходящих от родительского класса, то есть каждый последующий элемент он разветвляется на одинаковое количество элементов и разница между уровнями не более одной ступени:

Вот так еще можно     вот так уже нет
       5                     5     
     /   \                  / \  
    3     8                3    8   
   / \   / \                   / \
  1   4 6   9                6     9   
      /\                    / \   / \
    1   6                  3   7 5   11
   
для бинарных деревьев,для сбалансированных поиска существует только: 

search=O(log(N))

такая структура хороша в упорядоченном хранении данных,так эе она позволяет быстрый поиск данных.Например:
у нас есть дерево:
       5
     /   \
    3     8
   / \   / \
  1   4 6   9

и нам нужно найти обьект 4. мы можем посмотреть на ветки и значения которые обрели. мы смотрим 4- оно больше или меньше 8? Оно меньше , и то есть,нам в правое ответвление уже идти нет смысла. И мы переключаемся для поиска только на правую ветку.То есть мы за одну операцию,ровно половину нашей структуры данных,просто отрезали,убрали из радиуса по нашему взаимодействию. и вот так шаг за шагом, мы отрезаем половину наших  имеющихся данных. то есть такая структура поиска,она дает принцип "Разделяй и Властвуй".

Следующее:
Вставка:
N=2`H
Высота H=log(N)
когда нам нужно вместить новое значение в дерево:
У нас есть такие данные:
         100
        /   \
     50      200
     / \     / \  
  10   70  150  220
  |     |   |   |
null null null null
. Нам нужно вставит число 140 в наше дерево.  Мы смотрим значения какие есть и начинаем как всегда с самого корня.
Смотрим 140 меньше или больше 100--больше,переходим в правую часть,140 меньше или больше 150--меньше,переходим в право. и как только мы узнаем что под элементом 150- нет никаких значений,там NULL, то мы записываем это новое значение,мы заменяем NULL,и вписываем нужное и уже от него идет ответвление NULL
        100
       /    \
      50     200
     / \     / \
    10  70  150 220
   / \ / \  / \
   n  n   140 160
          / \   / \
         n  n   n  n

Так вот,вставка работает точно так же как и поиск,через логарифм
insert=log(N).
Высота H=log(N)

УДАЛЕНИЕ 
remove=O(log(n))
например 10-тки.По скольку под десяткой нету дочерних элементов,то она удаляется легко,но если нам например нужно удалить элемент,у которого есть дочернее число,то оно удаляется вместе с родителем

        100
       /   \
      50    200
     / \    /  \
    20 70  150 220
    /\ /\   /   \
   n n n n 140   160
           / \   / \
          n   n n   n

Но,что если нужно удалить значение 50?
        100
       /   \
      50    200
     / \    /  \
  20   70  150 220
  /\  /\   /   \
 n n 60 80 140   160
           / \   / \
          n   n n   n


поскольку под ним есть как левый узел,у который дочерний так и правый,он тоже дочерний.То,что происходит? Нам нужно передвижение элементов.при удалении подобного мы спускаемся по поиску,в самый низ.Как происходит поиск? Ищем меньшее(меньший элемент)- идем по левой стороне,нужно большее(максимальный элемент)- идем по правой стороне. так вот,нам нужно меньший(минимальный элемент)- мы спускаемся в самый низ и находим самое меньшее и заменяем его(то есть вставляем на место удаляемого, и так мы будем сохранять принцип,самого существования такого дерева и его алгоритма?оставлять его сбалансированным после всего) с сохранением всей структуры ответвлений.
        100
       /   \
      60    200
     / \    /  \
   20   70 150 220
   /\   /\  /   \
  n n  n 80 140   160
            / \   / \
           n   n n   n 
           
           
хеш-таблицы поскольку они не отсортированы и данные хранятся не в упорядоченном виде  и вставляются не в упорядоченную ячейку там все за константу,деревья-все за логарифм работает.и если нам важен упорядоченный вид-то мы используем дерево.