def findSmallest(arr):

  smallest = arr[0]
  smallest_index = 0
  for i in range(1, len(arr)):

    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
  return smallest_index

def selectionSort(arr):

  newArr = []
  for i in range(len(arr)):
      smallest = findSmallest(arr)  
      newArr.append(arr.pop(smallest))
  return newArr
print(selectionSort([5, 3, 6, 2, 10]))


def greet(name):

    print ( "hello, " + name + "!")
    greet2(name)
    print ("getting ready to say bye...")
    bye()

"""При вызове функции greet2 функция greet еще не была завершена.смысл этого раздела: когда мы вызываем функцию из другой функции, 
вызывающая функция приостанавливается в частично завершенном состоянии и все значения переменных этой функции остаются в памяти а 
когда выполнение функции greet2 будет завершено, мы возвращаемся к функции greet и продолжаем ее выполнение с того места, где оно 
прервалось."""
def greet2(name):
    print ("how are you, " + name + "?")

def bye():
    print ("ok bye!")
greet('Meg')


#факториал 5
def fact(x):

  if x == 1:
    return 1
  else:
    return x * fact(x-1)
print(fact(5))
"""
если мы говорим о поиске ключа в коробке,которая лежит в коробке и  та лежит еще в коробке Куча коробок» хранится в стеке! 
Это стек незавершенных вызовов функции, каждый из которых ведет собственный незаконченный список коробок 
для поиска. сохранение всей промежуточной информации может привести к значительным затратам памяти. Каждый вызов функции
занимает не много памяти, но если стек станет  слишком высоким, это будет означать, что ваш 
компьютер сохраняет информацию по очень многим  вызовам. На этой стадии есть два варианта:

• Переписать код с использованием цикла.
• Иногда можно воспользоваться так называемой хвостовой рекурсией. Это непростая тема, которая выходит за  рамки книги. Вдобавок она поддерживается далеко не во всех языках.

• Когда функция вызывает саму себя, это называется рекурсией.
• В каждой рекурсивной функции должно быть два случая: базовый и рекурсивный.
• Стек поддерживает две операции: занесение и извлечение элементов.
• Все вызовы функций сохраняются в стеке вызовов.
• Если стек вызовов станет очень большим, он займет слишком много памяти"""